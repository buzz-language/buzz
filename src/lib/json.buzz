import "std";
import "buffer";
import "errors";
import "serialize";

export object JsonParseError {
    str? message = null,
}

|| Parse JSON string into a `Json` tree
|| @private
object JsonParser {
    | TODO: comform to https://datatracker.ietf.org/doc/html/rfc8259

    str source,
    int offset = 0,

    fun advance() > str? {
        if (this.offset >= this.source.len()) {
            return null;
        }

        str char = this.source[this.offset];

        this.offset = this.offset + 1;

        return char;
    }

    fun peek() > str? {
        if (this.offset >= this.source.len()) {
            return null;
        }

        return this.source[this.offset];
    }

    fun match(str expected) > bool {
        if (this.offset > this.source.len() or this.source[this.offset] != expected) {
            return false;
        }

        this.offset = this.offset + 1;

        return true;
    }

    fun consume(str expected) > void !> JsonParseError {
        if (!this.match(expected)) {
            throw JsonParseError{ message = "Could not parse JSON: expected `{expected}` got `{this.peek()}` at offset {this.offset}" };
        }
    }

    fun skipWhitespaces() > void {
        while (true) {
            const str? char = this.peek();

            if (char == " " or char == "\r" or char == "\t" or char == "\n") {
                this.advance();
            } else {
                return;
            }
        }
    }

    fun next() > Boxed !> JsonParseError, WriteWhileReadingError {
        this.skipWhitespaces();

        if (this.offset >= this.source.len()) {
            throw JsonParseError{ message = "Could not parse JSON: end of string" };
        }

        const str char = this.advance() ?? "";
        const int byte = char.byte(0);
        if (char == "[") {
            return Boxed{ list = this.array() };
        } else if (char == "\{") {
            return Boxed{ map = this.map() };
        } else if ((byte >= "0".byte(0) and byte <= "9".byte(0)) or char == "-") {
            return this.number(char);
        } else if (char == "\"") {
            return Boxed{ string = this.string() };
        } else if (this.source.sub(this.offset - 1, len: 4) == "true") {
            this.offset = this.offset + 3;
            return Boxed{ boolean = true };
        } else if (this.source.sub(this.offset - 1, len: 5) == "false") {
            this.offset = this.offset + 4;
            return Boxed{ boolean = false };
        } else if (this.source.sub(this.offset - 1, len: 4) == "null") {
            this.offset = this.offset + 3;
            return Boxed{};
        }

        throw JsonParseError{ message = "Could not parse JSON: unexpected character `{char}` at offset {this.offset}" };
    }

    fun array() > [Boxed] !> JsonParseError, WriteWhileReadingError {
        [Boxed] array = [<Boxed>];

        while (true) {
            this.skipWhitespaces();

            if (this.match("]")) {
                break;
            }
                
            array.append(this.next());

            this.skipWhitespaces();

            if (this.match("]")) {
                break;
            } 

            this.consume(",");
        }

        return array;
    }

    fun map() > {str, Boxed} !> JsonParseError, WriteWhileReadingError {
        {str, Boxed} map = {<str, Boxed>};

        while (true) {
            this.skipWhitespaces();

            if (this.match("}")) {
                break;
            }

            this.consume("\"");
            const str key = this.string();

            this.skipWhitespaces();

            this.consume(":");

            this.skipWhitespaces();

            map[key] = this.next();

            this.skipWhitespaces();

            if (this.match("}")) {
                break;
            }

            this.consume(",");
        }

        return map;
    }

    fun number(str parsed) > Boxed !> JsonParseError {
        str number = parsed;

        bool isFloat = false;
        while (parseInt(this.peek() ?? "NaN") != null or this.peek() == ".") {
            str? char = this.advance();

            if (char == null) {
                break;
            }

            if (char == ".") {
                isFloat = true;
            }

            number = number + char!;
        }

        if (isFloat) {
            if (parseFloat(number) -> floating) {
                return Boxed{ floating = floating };
            }
        } else if (parseInt(number) -> integer) {
            return Boxed{ integer = integer };
        }
        
        throw JsonParseError{ message = "Could not parse JSON: `{number}` is not a number" };
    }

    fun string() > str !> WriteWhileReadingError {
        str? char = this.advance();
        Buffer string = Buffer.init();
        
        while (char != null and char != "\"") {
            if (char == "\\") {
                if (this.match("\"")) {
                    string.write("\"");
                } else if (this.match("\\")) {
                    string.write("\\");
                } else if (this.match("n")) {
                    string.write("\n");
                } else if (this.match("t")) {
                    string.write("\t");
                } else if (this.match("r")) {
                    string.write("\r");
                }
            } else {
                string.write(char!);
            }

            char = this.advance();
        }

        str result = string.toString();

        return result;
    }
}

|| Encode to a JSON string
|| @return the JSON string
export fun encode(Boxed data, {Boxed, void}? seen) > str {
    seen = seen ?? {<Boxed, void>};

    assert(seen![data] == null, message: "Circular reference in Boxed structure");
    seen![data] = void;

    if (data.string -> string) {
        return "\"{string}\"";
    } else if (data.boolean -> boolean) {
        return "{boolean}";
    } else if (data.integer -> integer) {
        return "{integer}";
    } else if (data.floating -> floating) {
        return "{floating}";
    } else if (data.map -> map) {
        str json = "\{";
        const int size = map.size();
        int count = 0;
        foreach (str key, Boxed value in map) {
            json = json + "\"{key}\":{encode(value, seen: seen)}";

            if (count < size - 1) {
                json = json + ",";
            }

            count = count + 1;
        }
        return json + "}";
    } else if (data.list -> list) {
        str json = "[";

        const int len = list.len();
        foreach (int i, Boxed value in list) {
            json = json + encode(value, seen: seen);

            if (i < len - 1) {
                json = json + ",";
            }
        }

        return json + "]";
    }

    return "null";
}

|| Decode string into a Json instance
|| @param str json The JSON string
|| @return Boxed
export fun decode(str json) > Boxed !> JsonParseError, WriteWhileReadingError {
    return JsonParser{ source = json }.next();
}

export Boxed;