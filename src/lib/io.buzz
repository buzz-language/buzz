namespace io;

import "errors";

/// @private
extern fun FileOpen(filename: str, mode: int) > ud !> errors\FileSystemError, errors\UnexpectedError;
/// @private
extern fun FileClose(file: ud) > void;
/// @private
extern fun FileReadAll(file: ud, maxSize: int?) > str !> errors\ReadWriteError, errors\FileSystemError, errors\UnexpectedError;
/// @private
extern fun FileReadLine(file: ud, maxSize: int?) > str? !> errors\ReadWriteError, errors\FileSystemError, errors\UnexpectedError;
/// @private
extern fun FileRead(file: ud, n: int) > str? !> errors\ReadWriteError, errors\FileSystemError, errors\InvalidArgumentError, errors\UnexpectedError;
/// @private
extern fun FileWrite(file: ud, bytes: str) > void !> errors\FileSystemError, errors\ReadWriteError, errors\UnexpectedError;
/// @private
extern fun getStdIn() > ud;
/// @private
extern fun getStdOut() > ud;
/// @private
extern fun getStdErr() > ud;
/// @private
extern fun FileIsTTY(file: ud) > bool;
/// @private
extern fun FileGetPoller(file: ud) > ud !> errors\FileSystemError, errors\ReadWriteError, errors\SocketError, errors\ExecError, error\UnexpectedError;
/// @private
extern fun PollerPoll(poller: ud, timeout: int?) > str? !> errors\ReadWriteError;
/// @private
extern fun PollerDeinit(poller: ud) > void;

/// File mode with which you can open a file
export enum FileMode {
    read,
    write,
    update,
}

/// Object to manipulate an opened file
export object File {
    /// File descriptor
    file: ud,

    /// @private
    released: bool = false,

    /// Open file
    /// @param filename Path of file to open
    /// @param mode Mode with which to open it
    /// @return opened file
    static fun open(filename: str, mode: FileMode) > mut File !> errors\FileSystemError, errors\UnexpectedError {
        return mut File {
            file = FileOpen(filename, mode: mode.value),
        };
    }

    mut fun collect() > void {
        if (!this.released) {
            this.released = true;
            this.close();
        }
    }

    /// Close file
    fun close() > void {
        FileClose(this.file);
    }

    /// Reads file until `EOF`
    /// @return Read data
    mut fun readAll(maxSize: int?) > str !> errors\ReadWriteError, errors\FileSystemError, errors\UnexpectedError {
        return FileReadAll(this.file, maxSize);
    }

    /// Reads next line, returns null if nothing to read
    /// @return Read data
    mut fun readLine(maxSize: int?) > str? !> errors\ReadWriteError, errors\FileSystemError, errors\UnexpectedError {
        return FileReadLine(this.file, maxSize);
    }

    /// Reads `n` bytes, returns null if nothing to read
    /// @param n how many bytes to read
    /// @return Read data
    mut fun read(n: int) > str? !> errors\ReadWriteError, errors\FileSystemError, errors\InvalidArgumentError, errors\UnexpectedError {
        return FileRead(this.file, n);
    }

    /// Write bytes
    /// @param bytes string to write
    fun write(bytes: str) > void !> errors\FileSystemError, errors\ReadWriteError, errors\UnexpectedError {
        FileWrite(this.file, bytes: bytes);
    }

    /// @return true if file is TTY
    fun isTTY() > bool {
        return FileIsTTY(this.file);
    }

    /// @return FilePoller that can be used to poll incoming data on that file
    fun getPoller() > FilePoller !> errors\FileSystemError, errors\ReadWriteError, errors\SocketError, errors\ExecError, error\UnexpectedError {
        return FilePoller{
            poller = FileGetPoller(this.file),
        };
    }
}

export object FilePoller {
    /// Underlying zig poller
    poller: ud,

    // Poll file, blocking for at most `timeout` before returning
    // @returns The string read if any, `null` otherwise
    fun poll(timeout: int?) > str? !> errors\ReadWriteError {
        return PollerPoll(this.poller, timeout);
    }

    fun collect() > void {
        this.deinit();
    }

    fun deinit() > void {
        PollerDeinit(this.poller);
    }
    
}

/// stdin
export final stdin = File{ file = getStdIn() };
/// stdout
export final stdout = File{ file = getStdOut() };
/// stderr
export final stderr = File{ file = getStdErr() };

/// Run a buzz file
/// @param filename path to buzz file
export extern fun runFile(filename: str) > void !> errors\CompileError, errors\InterpretError, errors\FileSystemError, errors\ReadWriteError;
