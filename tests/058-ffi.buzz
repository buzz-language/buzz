import "std";
import "buffer";
import "debug";
import "ffi";

| | TODO: one zdef for one lib and multiple declarations
| | TODO: Allow multiple declarations in one string
| zdef("tests/utils/libforeign", "fn acos(value: f64) f64;");
| | `[*:0]const u8` is the only pointer type that will be handled with an ObjString
| zdef("tests/utils/libforeign", "fn fprint(msg: [*:0]const u8) void;");
| zdef("tests/utils/libforeign", "fn sum(values: [*]i32, len: i32) i32;");

| test "scalar type" {
|     assert(acos(0.12) == 1.4505064444001086, message: "Could call FFI function with scalar arguments");
| }

| test "cstring" {
|     fprint(cstr("hello world"));
| }

| test "pointer with Buffer" {
|     | TODO: would be better with object destructor so the buffer can be collected
|     Buffer buffer = Buffer.init();

|     buffer.writeZ(<int>, "i32", values: [1, 2, 3]);
|     buffer.writeZ(<int>, "i32", values: [1, 2, 3]);

|     try {
|         | Arguably, the zig type parameter could a constant and be built at compile time
|         | But: that would require a new type
|         | Since we cache the result of the type parsing this roughly equivalent
|         buffer.writeZ(<int>, "u64", values: [1]);
|         assert(false, message: "Using bad buzz type triggers error");
|     } catch (FFITypeMismatchError error) {
|         assert(true, message: "Using bad buzz type triggers error");
|     }

|     int len = toInt(buffer.len() / 4);
|     int total = sum(buffer.ptr(), len: len);

|     assert(total == 12, message: "Could call FFI function with pointer argument");

|     int readTotal = 0;
|     foreach (int i in 0..toInt((buffer.len() / 4))) {
|         readTotal = readTotal + buffer.readZAt(<int>, i * 4, type: "i32");
|     }

|     assert(readTotal == total, message: "Could read from pointer");
| }

zdef("tests/utils/libforeign", `
    const Data = extern struct {
        msg: [*:0]const u8,
        id: i32,
    };
`);

zdef("tests/utils/libforeign", "fn getDataMsg(data: *Data) [*:0]const u8;");
zdef("tests/utils/libforeign", "fn setDataId(data: *Data) void;");

test "struct" {
    Data data = Data{
        msg = cstr("bye world"),
        id = 123,
    };

    assert(data.msg == "bye world\0", message: "Could instanciate Zig struct");
    assert(data.id == 123, message: "Could instanciate Zig struct");

    data.id = 42;

    assert(data.id == 42, message: "Could set Zig struct field");

    assert(getDataMsg(data) == "bye world\0", message: "Could use foreign function with struct ptr param");

    setDataId(data);

    assert(data.id == 84, message: "Could use foreign function with struct ptr param that modifies the struct");
}
